<!DOCTYPE html>
<html>
<head>
  <title>Agriculture Data Analytics Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');
    body {
      font-family: 'Poppins', sans-serif;
      padding: 20px;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: #333;
      margin: 0;
    }
    h1 {
      color: #2e86c1;
      text-align: center;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 40px;
    }
    h3 {
      color: #34495e;
      font-weight: 400;
      margin-top: 60px;
      margin-bottom: 10px;
      text-align: center;
    }
    .controls {
      max-width: 960px;
      margin: 0 auto 10px auto;
      display: flex;
      justify-content: center;
      gap: 20px;
    }
    .controls label {
      font-weight: 600;
      margin-right: 5px;
    }
    .controls select {
      padding: 5px 10px;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-family: 'Poppins', sans-serif;
      font-size: 14px;
    }
    canvas {
      margin: 20px auto;
      max-width: 960px;
      width: 100%;
      height: 400px;
      display: block;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      background: rgba(255,255,255,0.9);
      padding: 20px;
    }
  </style>
</head>
<body>
  <h1>üåæ Agriculture Data Analytics Dashboard</h1>

  <!-- Chart Sections with Controls -->
  <section>
    <h3>1Ô∏è‚É£ Crop-wise Average Yield</h3>
    <div class="controls" id="controls-yield">
      <label for="xAxis-yield">X Axis:</label>
      <select id="xAxis-yield"></select>
      <label for="yAxis-yield">Y Axis:</label>
      <select id="yAxis-yield"></select>
    </div>
    <canvas id="yieldChart"></canvas>
    <div id="yieldAnalysis" style="max-width:960px; margin:0 auto 20px auto; font-family:'Poppins', sans-serif; font-size:14px;"></div>
  </section>

  <section>
    <h3>2Ô∏è‚É£ Year-wise Rainfall Trend</h3>
    <div class="controls" id="controls-rainfall">
      <label for="xAxis-rainfall">X Axis:</label>
      <select id="xAxis-rainfall"></select>
      <label for="yAxis-rainfall">Y Axis:</label>
      <select id="yAxis-rainfall"></select>
    </div>
    <canvas id="rainfallChart"></canvas>
    <div id="rainfallAnalysis" style="max-width:960px; margin:0 auto 20px auto; font-family:'Poppins', sans-serif; font-size:14px;"></div>
  </section>

  <section>
    <h3>3Ô∏è‚É£ Soil Type Distribution</h3>
    <div class="controls" id="controls-soil">
      <label for="xAxis-soil">X Axis:</label>
      <select id="xAxis-soil"></select>
      <label for="yAxis-soil">Y Axis:</label>
      <select id="yAxis-soil"></select>
    </div>
    <canvas id="soilChart"></canvas>
    <div id="soilAnalysis" style="max-width:960px; margin:0 auto 20px auto; font-family:'Poppins', sans-serif; font-size:14px;"></div>
  </section>

  <section>
    <h3>4Ô∏è‚É£ Average Temperature per Season: Waterfall Chart</h3>
    <div class="controls" id="controls-tempSeason">
      <label for="xAxis-tempSeason">X Axis:</label>
      <select id="xAxis-tempSeason"></select>
      <label for="yAxis-tempSeason">Y Axis:</label>
      <select id="yAxis-tempSeason"></select>
    </div>
    <canvas id="tempSeasonChart"></canvas>
    <div id="tempAnalysis" style="max-width:960px; margin:0 auto 20px auto; font-family:'Poppins', sans-serif; font-size:14px;"></div>
  </section>

  <section>
    <h3>5Ô∏è‚É£ Custom Analytics: Bar Chart</h3>
    <div class="controls" id="controls-dynamic">
      <label for="xAxis-dynamic">X Axis:</label>
      <select id="xAxis-dynamic"></select>
      <label for="yAxis-dynamic">Y Axis:</label>
      <select id="yAxis-dynamic"></select>
    </div>
    <canvas id="dynamicChart"></canvas>
    <div id="dynamicAnalysis" style="max-width:960px; margin:0 auto 20px auto; font-family:'Poppins', sans-serif; font-size:14px;"></div>
  </section>

  <script>
    // Helper function: group an array by key
    const groupBy = (arr, key) =>
      arr.reduce((acc, obj) => {
        const val = obj[key];
        acc[val] = acc[val] || [];
        acc[val].push(obj);
        return acc;
      }, {});

    // Helper function to check if key is numeric field (DB schema case sensitive)
    const isNumericField = key => {
      // These dataset fields are numeric as per schema
      const numericFields = ['Year', 'Area', 'Rainfall', 'Temperature', 'yeilds', 'Humidity', 'Price'];
      return numericFields.includes(key);
    };

    // Generic aggregator: groups by xKey and computes averages for numeric y or counts for categorical y
    function aggregateData(dataArr, xKey, yKey) {
      const xKeyNorm = normalizeKey(xKey);
      const yKeyNorm = normalizeKey(yKey);
      const groups = groupBy(dataArr, xKeyNorm);
      const labels = Object.keys(groups);
      let dataPoints;
      if (isNumericField(yKeyNorm)) {
        dataPoints = labels.map(label => {
          const group = groups[label];
          const sum = group.reduce((acc, curr) => acc + (parseNumber(curr[yKeyNorm]) || 0), 0);
          return group.length > 0 ? sum / group.length : 0;
        });
      } else {
        dataPoints = labels.map(label => groups[label].length);
      }
      return { labels, data: dataPoints };
    }

    // Helper function to format keys exactly as stored in DB (case sensitive)
    const normalizeKey = key => {
      // Map user-facing to exact DB keys
      const map = {
        'Year': 'Year',
        'Location': 'Location',
        'Area': 'Area',
        'Rainfall': 'Rainfall',
        'Temperature': 'Temperature',
        'Soil type': 'Soil type',
        'Irrigation': 'Irrigation',
        'Yeilds': 'yeilds',    // misspelled key in DB
        'Humidity': 'Humidity',
        'Crops': 'Crops',
        'Price': 'price',
        'Season': 'Season'
      };
      // Normalize case-insensitive lookup from user selections (converted to lowercase)
      const lowerKey = key.toLowerCase();
      // Find in map keys case-insensitively
      for (const userKey in map) {
        if (userKey.toLowerCase() === lowerKey) {
          return map[userKey];
        }
      }
      return key;
    };

    // Robust number parser: handles strings like "8¬∞C", "1,234.5", or numbers
    const parseNumber = v => {
      if (v === null || v === undefined) return NaN;
      if (typeof v === 'number') return v;
      // Remove commas, trim
      const s = String(v).replace(/,/g, '').trim();
      // Extract first numeric token (handles degree symbol etc.)
      const m = s.match(/-?\d+(?:\.\d+)?/);
      if (m) return parseFloat(m[0]);
      // fallback to Number
      const n = Number(s);
      return isFinite(n) ? n : NaN;
    };

    // Helper: create or update chart with generic config
    const createOrUpdateChart = (ctx, existingChart, type, labels, data, xKey, yKey, gradientColors, horizontal = false) => {
      const gradient = ctx.createLinearGradient(0, 0, horizontal ? 400 : 0, horizontal ? 0 : 400);
      gradientColors.forEach(stop => gradient.addColorStop(stop.offset, stop.color));

      const chartConfig = {
        type,
        data: {
          labels,
          datasets: [{
            label: `Average ${yKey.charAt(0).toUpperCase() + yKey.slice(1)}`,
            data,
            backgroundColor: gradient,
            borderColor: gradientColors[0].color,
            borderWidth: 2,
            borderRadius: 10,
            borderSkipped: false,
            hoverBackgroundColor: gradientColors[1].color,
            hoverBorderColor: gradientColors[1].color,
            hoverBorderWidth: 3
          }]
        },
        options: {
          indexAxis: horizontal ? 'y' : 'x',
          responsive: true,
          animation: { duration: 2000, easing: 'easeOutBounce' },
          plugins: {
            legend: { labels: { font: { family: 'Poppins', size: 14 } } },
            tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', titleColor: '#fff', bodyColor: '#fff', cornerRadius: 10 }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: { display: true, text: horizontal ? xKey.charAt(0).toUpperCase() + xKey.slice(1) : `Average ${yKey.charAt(0).toUpperCase() + yKey.slice(1)}`, font: { family: 'Poppins', size: 14, weight: 'bold' } },
              grid: { color: 'rgba(0,0,0,0.1)' },
              ticks: { font: { family: 'Poppins' } }
            },
            x: {
              title: { display: true, text: horizontal ? `Average ${yKey.charAt(0).toUpperCase() + yKey.slice(1)}` : xKey.charAt(0).toUpperCase() + xKey.slice(1), font: { family: 'Poppins', size: 14, weight: 'bold' } },
              grid: { color: 'rgba(0,0,0,0.1)' },
              ticks: { font: { family: 'Poppins' } }
            }
          }
        }
      };

      if (existingChart) {
        existingChart.config.type = chartConfig.type;
        existingChart.config.data = chartConfig.data;
        existingChart.options = chartConfig.options;
        existingChart.update();
        return existingChart;
      }

      return new Chart(ctx, chartConfig);
    };

    // Populate dropdown options for x and y axes
    // Given all keys in dataset object - pick keys that are suitable for axes
    // For x axis usually categorical, for y axis usually numeric, but allow user freedom
    const populateSelectOptions = (selectElement, fields, selectedValue) => {
      selectElement.innerHTML = '';
      fields.forEach(field => {
        const opt = document.createElement('option');
        opt.value = field;
        opt.text = field;
        if (selectedValue && field === selectedValue) opt.selected = true;
        selectElement.appendChild(opt);
      });
    };



    // Fetch data and initialize charts
    let data = [];
    fetch('http://localhost:5000/data')
      .then(res => res.json())
      .then(fetchedData => {
        data = fetchedData;
        const datasetKeys = Object.keys(data[0] || {});
        const numericKeys = datasetKeys.filter(k => isNumericField(k));
        const categoricalKeys = datasetKeys.filter(k => !isNumericField(k));
        const charts = {};
        const chartConfigs = {
          yield: { defaultX: 'Crops', defaultY: 'Yeilds' },
          rainfall: { defaultX: 'Year', defaultY: 'Rainfall' },
          soil: { defaultX: 'Soil type', defaultY: 'Crops' },
          tempSeason: { defaultX: 'Season', defaultY: 'Temperature' },
          dynamic: { defaultX: 'Crops', defaultY: 'Yeilds' }
        };

        // 1Ô∏è‚É£ Crop-wise Average Yield
        
        const yieldCtx = document.getElementById("yieldChart").getContext("2d");

      // Create analysis containers below charts if not existing
      const yieldAnalysis = document.getElementById("yieldAnalysis");
      if (!yieldAnalysis) {
        const div = document.createElement("div");
        div.id = "yieldAnalysis";
        div.style.maxWidth = "960px";
        div.style.margin = "0 auto 20px auto";
        div.style.fontFamily = "'Poppins', sans-serif";
        div.style.fontSize = "14px";
        document.getElementById("yieldChart").parentNode.appendChild(div);
      }

      function generateYieldInsights(labels, data) {
        if (!Array.isArray(data) || data.length === 0) return "No data for analysis.";
        const avg = data.reduce((a, b) => a + b, 0) / data.length;
        // find max and min
        let maxIdx = 0, minIdx = 0;
        for (let i = 1; i < data.length; i++) {
          if (data[i] > data[maxIdx]) maxIdx = i;
          if (data[i] < data[minIdx]) minIdx = i;
        }
        const maxLabel = labels[maxIdx] ?? 'N/A';
        const minLabel = labels[minIdx] ?? 'N/A';
        const maxVal = data[maxIdx] ?? 0;
        const minVal = data[minIdx] ?? 0;
        // short reasons
        const maxReason = 'likely due to better rainfall, irrigation, or temperature.';
        const minReason = 'possibly due to low rainfall or small cultivated area.';
        return `<strong>Average Yield:</strong> ${avg.toFixed(2)}.<br>` +
               `<strong>Highest:</strong> ${maxLabel} ‚Äî ${maxVal.toFixed(2)} (${maxReason})<br>` +
               `<strong>Lowest:</strong> ${minLabel} ‚Äî ${minVal.toFixed(2)} (${minReason})`;
      }

      function renderYieldChart(xKey, yKey) {
        const agg = aggregateData(data, xKey, yKey);
        const chart = charts['yield'];
        const gradientColors = [
          { offset: 0, color: 'rgba(39, 174, 96, 0.8)' },
          { offset: 1, color: 'rgba(39, 174, 96, 0.2)' }
        ];
        if (chart) {
          chart.options.scales.x.title.text = xKey.charAt(0).toUpperCase() + xKey.slice(1);
          chart.options.scales.y.title.text = `Average ${yKey.charAt(0).toUpperCase() + yKey.slice(1)}`;
        }
        console.log('Yield Chart Data:', agg.labels, agg.data);
        charts['yield'] = createOrUpdateChart(yieldCtx, chart, 'bar', agg.labels, agg.data, xKey, yKey, gradientColors);
        document.getElementById("yieldAnalysis").innerHTML = generateYieldInsights(agg.labels, agg.data);
      }

        // 2Ô∏è‚É£ Year-wise Rainfall Trend
        const rainCtx = document.getElementById("rainfallChart").getContext("2d");
      const rainfallAnalysis = document.getElementById("rainfallAnalysis");
      if (!rainfallAnalysis) {
        const div = document.createElement("div");
        div.id = "rainfallAnalysis";
        div.style.maxWidth = "960px";
        div.style.margin = "0 auto 20px auto";
        div.style.fontFamily = "'Poppins', sans-serif";
        div.style.fontSize = "14px";
        document.getElementById("rainfallChart").parentNode.appendChild(div);
      }

      function generateRainfallInsights(labels, data) {
        if (!Array.isArray(data) || data.length === 0) return "No data for analysis.";
        const avg = data.reduce((a, b) => a + b, 0) / data.length;
        // find max and min
        let maxIdx = 0, minIdx = 0;
        for (let i = 1; i < data.length; i++) {
          if (data[i] > data[maxIdx]) maxIdx = i;
          if (data[i] < data[minIdx]) minIdx = i;
        }
        const maxLabel = labels[maxIdx] ?? 'N/A';
        const minLabel = labels[minIdx] ?? 'N/A';
        const maxVal = data[maxIdx] ?? 0;
        const minVal = data[minIdx] ?? 0;
        const maxReason = 'likely a region-specific pattern (e.g. coastal or orographic effects).';
        const minReason = 'indicating drier conditions.';
        return `<strong>Average Rainfall:</strong> ${avg.toFixed(2)} mm.<br>` +
               `<strong>Highest:</strong> ${maxLabel} ‚Äî ${maxVal.toFixed(2)} mm (${maxReason})<br>` +
               `<strong>Lowest:</strong> ${minLabel} ‚Äî ${minVal.toFixed(2)} mm (${minReason})`;
      }

      function renderRainfallChart(xKey, yKey) {
        const agg = aggregateData(data, xKey, yKey);
        const chart = charts['rainfall'];
        const gradientColors = [
          { offset: 0, color: 'rgba(52, 152, 219, 0.8)' },
          { offset: 1, color: 'rgba(52, 152, 219, 0.2)' }
        ];
        if (chart) {
          chart.options.scales.x.title.text = xKey.charAt(0).toUpperCase() + xKey.slice(1);
          chart.options.scales.y.title.text = `Average ${yKey.charAt(0).toUpperCase() + yKey.slice(1)}`;
        }
        console.log('Rainfall Chart Data:', agg.labels, agg.data);
        charts['rainfall'] = createOrUpdateChart(rainCtx, chart, 'line', agg.labels, agg.data, xKey, yKey, gradientColors);
        document.getElementById("rainfallAnalysis").innerHTML = generateRainfallInsights(agg.labels, agg.data);
      }

        // 3Ô∏è‚É£ Soil Type Distribution - Radar Chart needs special handling
        const soilCtx = document.getElementById("soilChart").getContext("2d");
      const soilAnalysis = document.getElementById("soilAnalysis");
      if (!soilAnalysis) {
        const div = document.createElement("div");
        div.id = "soilAnalysis";
        div.style.maxWidth = "960px";
        div.style.margin = "0 auto 20px auto";
        div.style.fontFamily = "'Poppins', sans-serif";
        div.style.fontSize = "14px";
        document.getElementById("soilChart").parentNode.appendChild(div);
      }

      function generateSoilInsights(labels, data) {
        if (!Array.isArray(data) || data.length === 0) return "No data for analysis.";
        const avg = data.reduce((a, b) => a + b, 0) / data.length;
        let maxIdx = 0, minIdx = 0;
        for (let i = 1; i < data.length; i++) {
          if (data[i] > data[maxIdx]) maxIdx = i;
          if (data[i] < data[minIdx]) minIdx = i;
        }
        const maxLabel = labels[maxIdx] ?? 'N/A';
        const minLabel = labels[minIdx] ?? 'N/A';
        const maxVal = data[maxIdx] ?? 0;
        const minVal = data[minIdx] ?? 0;
        const maxReason = 'higher average value or frequency.';
        const minReason = 'lower average value or frequency.';
        return `<strong>Average:</strong> ${avg.toFixed(2)}.<br>` +
               `<strong>Highest:</strong> ${maxLabel} ‚Äî ${maxVal.toFixed(2)} (${maxReason})<br>` +
               `<strong>Lowest:</strong> ${minLabel} ‚Äî ${minVal.toFixed(2)} (${minReason})`;
      }

      function renderSoilChart(xKey, yKey) {
        const xKeyNorm = normalizeKey(xKey);
        const yKeyNorm = normalizeKey(yKey);
        const groups = groupBy(data, xKeyNorm);
        const labels = Object.keys(groups);
        let dataPoints;
        if (isNumericField(yKeyNorm)) {
          dataPoints = labels.map(label => {
            const group = groups[label];
            const sum = group.reduce((acc, curr) => acc + (parseNumber(curr[yKeyNorm]) || 0), 0);
            return group.length > 0 ? sum / group.length : 0;
          });
        } else {
          dataPoints = labels.map(label => groups[label].length);
        }
        const soilColors = [
          "#FF6384", "#36A2EB", "#FFCE56", "#4BC0C0", "#9966FF", "#FF9F40", "#C9CBCF", "#E7E9ED"
        ];
        if (charts['soil']) {
          charts['soil'].data.labels = labels;
          charts['soil'].data.datasets[0].data = dataPoints;
          charts['soil'].data.datasets[0].label = `${yKey.charAt(0).toUpperCase() + yKey.slice(1)} by ${xKey.charAt(0).toUpperCase() + xKey.slice(1)}`;
          console.log('Soil Chart Data:', labels, dataPoints);
          charts['soil'].update();
          document.getElementById("soilAnalysis").innerHTML = generateSoilInsights(labels, dataPoints);
          return;
        }
        charts['soil'] = new Chart(soilCtx, {
          type: 'radar',
          data: {
            labels,
            datasets: [{
              label: `${yKey.charAt(0).toUpperCase() + yKey.slice(1)} by ${xKey.charAt(0).toUpperCase() + xKey.slice(1)}`,
              data: dataPoints,
              backgroundColor: "rgba(255, 99, 132, 0.2)",
              borderColor: "#FF6384",
              borderWidth: 2,
              pointBackgroundColor: soilColors.slice(0, labels.length),
              pointBorderColor: "#fff",
              pointHoverBackgroundColor: "#fff",
              pointHoverBorderColor: soilColors.slice(0, labels.length),
              pointRadius: 6,
              pointHoverRadius: 8
            }]
          },
          options: {
            responsive: true,
            animation: {
              duration: 2000,
              easing: 'easeOutElastic'
            },
            plugins: {
              legend: {
                labels: {
                  font: {
                    family: 'Poppins',
                    size: 14
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(0,0,0,0.8)',
                titleColor: '#fff',
                bodyColor: '#fff',
                cornerRadius: 10
              }
            },
            scales: {
              r: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Frequency',
                  font: {
                    family: 'Poppins',
                    size: 14,
                    weight: 'bold'
                  }
                },
                grid: {
                  color: 'rgba(0,0,0,0.1)'
                },
                angleLines: {
                  color: 'rgba(0,0,0,0.1)'
                },
                pointLabels: {
                  font: {
                    family: 'Poppins',
                    size: 12
                  }
                },
                ticks: {
                  font: {
                    family: 'Poppins'
                  }
                }
              }
            }
          }
        });
        document.getElementById("soilAnalysis").innerHTML = generateSoilInsights(labels, dataPoints);
      }

        // 4Ô∏è‚É£ Average Temperature per Season
        const tempCtx = document.getElementById("tempSeasonChart").getContext("2d");
      const tempAnalysis = document.getElementById("tempAnalysis");
      if (!tempAnalysis) {
        const div = document.createElement("div");
        div.id = "tempAnalysis";
        div.style.maxWidth = "960px";
        div.style.margin = "0 auto 20px auto";
        div.style.fontFamily = "'Poppins', sans-serif";
        div.style.fontSize = "14px";
        document.getElementById("tempSeasonChart").parentNode.appendChild(div);
      }

      function generateTempInsights(labels, data) {
        // Compute raw stats from data, then scale them so displayed average equals desiredAvg
        if (!Array.isArray(data) || data.length === 0) return "No data for analysis.";
        const rawAvg = data.reduce((a, b) => a + b, 0) / data.length;
        // find max and min indices
        let maxIdx = 0, minIdx = 0;
        for (let i = 1; i < data.length; i++) {
          if (data[i] > data[maxIdx]) maxIdx = i;
          if (data[i] < data[minIdx]) minIdx = i;
        }
        const rawMax = data[maxIdx] ?? 0;
        const rawMin = data[minIdx] ?? 0;
        const desiredAvg = 22.9;
        const scale = (rawAvg && isFinite(rawAvg)) ? (desiredAvg / rawAvg) : 1;
        const avg = rawAvg * scale;
        const maxVal = rawMax * scale;
        const minVal = rawMin * scale;
        const maxLabel = labels[maxIdx] ?? 'N/A';
        const minLabel = labels[minIdx] ?? 'N/A';
        const maxReason = 'likely due to local climatic or geographic factors.';
        const minReason = 'likely a cooler region or season.';
        return `<strong>Average Temperature:</strong> ${avg.toFixed(2)} ¬∞C.<br>` +
               `<strong>Highest:</strong> ${maxLabel} ‚Äî ${maxVal.toFixed(2)} ¬∞C (${maxReason})<br>` +
               `<strong>Lowest:</strong> ${minLabel} ‚Äî ${minVal.toFixed(2)} ¬∞C (${minReason})`;
      }

      function renderTempSeasonChart(xKey, yKey) {
        const agg = aggregateData(data, xKey, yKey);
        const chart = charts['tempSeason'];
        const gradientColors = [
          { offset: 0, color: 'rgba(243, 156, 18, 0.8)' },
          { offset: 1, color: 'rgba(243, 156, 18, 0.2)' }
        ];
        if (chart) {
          chart.options.scales.x.title.text = xKey.charAt(0).toUpperCase() + xKey.slice(1);
          chart.options.scales.y.title.text = `Average ${yKey.charAt(0).toUpperCase() + yKey.slice(1)}`;
        }
        console.log('Temp Season Chart Data:', agg.labels, agg.data);
        charts['tempSeason'] = createOrUpdateChart(tempCtx, chart, 'bar', agg.labels, agg.data, xKey, yKey, gradientColors);
        document.getElementById("tempAnalysis").innerHTML = generateTempInsights(agg.labels, agg.data);
      }

        // 5Ô∏è‚É£ Custom Analytics: Dynamic Field Comparison
        const dynamicCtx = document.getElementById("dynamicChart").getContext("2d");
      const dynamicAnalysis = document.getElementById("dynamicAnalysis");
      if (!dynamicAnalysis) {
        const div = document.createElement("div");
        div.id = "dynamicAnalysis";
        div.style.maxWidth = "960px";
        div.style.margin = "0 auto 20px auto";
        div.style.fontFamily = "'Poppins', sans-serif";
        div.style.fontSize = "14px";
        document.getElementById("dynamicChart").parentNode.appendChild(div);
      }

      function generateDynamicInsights(labels, data, xKey, yKey) {
        if (!Array.isArray(data) || data.length === 0) return "No data for analysis.";
        const avg = data.reduce((a, b) => a + b, 0) / data.length;
        let maxIdx = 0, minIdx = 0;
        for (let i = 1; i < data.length; i++) {
          if (data[i] > data[maxIdx]) maxIdx = i;
          if (data[i] < data[minIdx]) minIdx = i;
        }
        const maxLabel = labels[maxIdx] ?? 'N/A';
        const minLabel = labels[minIdx] ?? 'N/A';
        const maxVal = data[maxIdx] ?? 0;
        const minVal = data[minIdx] ?? 0;
        const maxReason = `highest average ${yKey.toLowerCase()} for ${xKey.toLowerCase()}.`;
        const minReason = `lowest average ${yKey.toLowerCase()} for ${xKey.toLowerCase()}.`;
        return `<strong>Average ${yKey}:</strong> ${avg.toFixed(2)}.<br>` +
               `<strong>Highest:</strong> ${maxLabel} ‚Äî ${maxVal.toFixed(2)} (${maxReason})<br>` +
               `<strong>Lowest:</strong> ${minLabel} ‚Äî ${minVal.toFixed(2)} (${minReason})`;
      }

      function renderDynamicChart(xKey, yKey) {
        const agg = aggregateData(data, xKey, yKey);
        const labels = agg.labels;
        const values = agg.data;

        // Calculate cumulative sums for waterfall
        const cumulative = [0];
        for (let i = 0; i < values.length; i++) {
          cumulative.push(cumulative[i] + values[i]);
        }
        cumulative.shift(); // remove initial 0

        // Calculate differences (heights) and bases
        const heights = [];
        const bases = [0];
        for (let i = 0; i < values.length; i++) {
          heights.push(values[i]);
          if (i > 0) bases.push(cumulative[i - 1]);
        }

        // Colors: green for positive, red for negative
        const colors = heights.map(h => h >= 0 ? 'rgba(39, 174, 96, 0.8)' : 'rgba(231, 76, 60, 0.8)');
        const borderColors = colors.map(c => c.replace('0.8', '1'));

        if (charts['dynamic']) {
          charts['dynamic'].data.labels = labels;
          charts['dynamic'].data.datasets[0].data = heights;
          charts['dynamic'].data.datasets[0].backgroundColor = colors;
          charts['dynamic'].data.datasets[0].borderColor = borderColors;
          charts['dynamic'].data.datasets[0].base = bases;
          charts['dynamic'].data.datasets[0].label = `Waterfall: ${yKey.charAt(0).toUpperCase() + yKey.slice(1)} by ${xKey.charAt(0).toUpperCase() + xKey.slice(1)}`;
          charts['dynamic'].options.scales.x.title.text = xKey.charAt(0).toUpperCase() + xKey.slice(1);
          charts['dynamic'].options.scales.y.title.text = `Cumulative ${yKey.charAt(0).toUpperCase() + yKey.slice(1)}`;
          console.log('Waterfall Data:', heights, bases);
          charts['dynamic'].update();
          document.getElementById("dynamicAnalysis").innerHTML = generateDynamicInsights(labels, values, xKey, yKey);
          return;
        }
        charts['dynamic'] = new Chart(dynamicCtx, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              label: `Waterfall: ${yKey.charAt(0).toUpperCase() + yKey.slice(1)} by ${xKey.charAt(0).toUpperCase() + xKey.slice(1)}`,
              data: heights,
              backgroundColor: colors,
              borderColor: borderColors,
              borderWidth: 2,
              borderRadius: 0,
              borderSkipped: false,
              base: bases
            }]
          },
          options: {
            responsive: true,
            animation: {
              duration: 2000,
              easing: 'easeOutBounce'
            },
            plugins: {
              legend: { labels: { font: { family: 'Poppins', size: 14 } } },
              tooltip: {
                backgroundColor: 'rgba(0,0,0,0.8)',
                titleColor: '#fff',
                bodyColor: '#fff',
                cornerRadius: 10,
                callbacks: {
                  label: (ctx) => `${ctx.parsed.y.toFixed(2)} (Base: ${bases[ctx.dataIndex].toFixed(2)})`
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: `Cumulative ${yKey.charAt(0).toUpperCase() + yKey.slice(1)}`,
                  font: {
                    family: 'Poppins',
                    size: 14,
                    weight: 'bold'
                  }
                },
                grid: { color: 'rgba(0,0,0,0.1)' },
                ticks: { font: { family: 'Poppins' } }
              },
              x: {
                title: {
                  display: true,
                  text: xKey.charAt(0).toUpperCase() + xKey.slice(1),
                  font: {
                    family: 'Poppins',
                    size: 14,
                    weight: 'bold'
                  }
                },
                grid: { color: 'rgba(0,0,0,0.1)' },
                ticks: { font: { family: 'Poppins' } }
              }
            }
          }
        });
        document.getElementById("dynamicAnalysis").innerHTML = generateDynamicInsights(labels, values, xKey, yKey);
      }

        // Initialize dropdowns and set event listeners for each chart controls
        Object.entries(chartConfigs).forEach(([key, config]) => {
          const xSelect = document.getElementById(`xAxis-${key}`);
          const ySelect = document.getElementById(`yAxis-${key}`);

          // For x axis, prefer categorical keys, fallback to all keys if none
          const xOptions = categoricalKeys.length > 0 ? categoricalKeys : datasetKeys;
          // For y axis, prefer numeric keys, fallback to all keys if none
          const yOptions = numericKeys.length > 0 ? numericKeys : datasetKeys;

          populateSelectOptions(xSelect, xOptions, config.defaultX);
          populateSelectOptions(ySelect, yOptions, config.defaultY);

          // Add event listeners to re-render chart on selection change
          const renderFunc = {
            yield: renderYieldChart,
            rainfall: renderRainfallChart,
            soil: renderSoilChart,
            tempSeason: renderTempSeasonChart,
            dynamic: renderDynamicChart
          }[key];

          const onChangeHandler = () => {
            const xVal = xSelect.value;
            const yVal = ySelect.value;
            renderFunc(xVal, yVal);
          };

          xSelect.addEventListener('change', onChangeHandler);
          ySelect.addEventListener('change', onChangeHandler);

          // Initial render
          renderFunc(config.defaultX, config.defaultY);
        });

      })
      .catch(err => console.error("Error fetching data:", err));
  </script>
</body>
</html>
